计算机是带符号的，在计算机中用一个数的最高位存放符号，正数为0，负数为1

- 3  -> 00000011 
- -3 -> 10000011

### 原码

源码就是用符号位加上真值的绝对值，因为第一位是符号位，所以8位二进制的取值范围就是 		[11111111,011111111] 也就是 [-127,127]

### 反码

- 正数的反码就是本身 00000001 -> 00000001
- 负数的反码是在其源码的基础上，符号位不变，其余各位取反 10000001-> 11111110

### 补码

- 正数的补码是其本身 00000001 -> 00000001

- 附属的补码是在原码的基础上，符号位不变，其余各位取反，最后 +1，也就是反码的基础+1 

  10000001-> 11111111

### 为什么要用原码、反码和补码

因为第一位是符号位，如果让计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂， 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.

#### 用原码计算 1-1，明显是错的

> 1 - 1 = 1 + (-1) = [00000001] + [10000001] = [10000010] = -2 

#### 用反码计算 3-3

> 3 -3 = 3 + (-3) = [00000011] + [10000011] (原) = [00000011] + [11111100] (反) = [11111111] (反) = [10000000] (原) = -0 
>
> 用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在"0"这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0.

#### 用补码计算 1-1 ，解决了0的符号以及两个编码的问题

> 1-1 = 1 + (-1) = [00000001] + [10000001] (原) = [00000001] + [11111111] (补) = [00000000] (补) = [00000000] (原)

这样 0 用 [00000000] 表示，可以用 [10000000] 表示-128了 

> (-1) + (-127) = [10000001] + [11111111] (原) = [11111111] + [10000001] (补) = [10000000] (补)

需要注意的是 在用补码运算的结果中, [1000 0000] (补) 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.对-128的补码表示[1000 0000 (补)算出来的原码是[0000 0000] (原), 这是不正确的)

使用补码，不仅修复了0的符号问提以及两个编码的问题，而且还能够多表示一个最低数，这就是为什么8为二进制，使用原码和反码表示的范围是[-127-127]，而使用补码表示的范围是 [-128,127]

因为计算机用的是补码，所以编程中常用到的 32位 Int 类型可表示的范围是 [-2^31, 2^31-1]

  





